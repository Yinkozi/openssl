=pod

=head1 NAME

EVVP_MD_CTX_new, EVVP_MD_CTX_reset, EVVP_MD_CTX_free, EVVP_MD_CTX_copy,
EVVP_MD_CTX_copy_ex, EVVP_MD_CTX_ctrl, EVVP_MD_CTX_set_flags,
EVVP_MD_CTX_clear_flags, EVVP_MD_CTX_test_flags,
EVVP_Digest, EVVP_DigestInit_ex, EVVP_DigestInit, EVVP_DigestUpdate,
EVVP_DigestFinal_ex, EVVP_DigestFinalXOF, EVVP_DigestFinal,
EVVP_MD_type, EVVP_MD_pkey_type, EVVP_MD_size, EVVP_MD_block_size, EVVP_MD_flags,
EVVP_MD_CTX_md, EVVP_MD_CTX_type, EVVP_MD_CTX_size, EVVP_MD_CTX_block_size,
EVVP_MD_CTX_md_data, EVVP_MD_CTX_update_fn, EVVP_MD_CTX_set_update_fn,
EVVP_md_null,
EVVP_get_digestbyname, EVVP_get_digestbynid, EVVP_get_digestbyobj,
EVVP_MD_CTX_pkey_ctx, EVVP_MD_CTX_set_pkey_ctx - EVVP digest routines

=head1 SYNOPSIS

 #include <openssl/evp.h>

 EVVP_MD_CTX *EVVP_MD_CTX_new(void);
 int EVVP_MD_CTX_reset(EVVP_MD_CTX *ctx);
 void EVVP_MD_CTX_free(EVVP_MD_CTX *ctx);
 void EVVP_MD_CTX_ctrl(EVVP_MD_CTX *ctx, int cmd, int p1, void* p2);
 void EVVP_MD_CTX_set_flags(EVVP_MD_CTX *ctx, int flags);
 void EVVP_MD_CTX_clear_flags(EVVP_MD_CTX *ctx, int flags);
 int EVVP_MD_CTX_test_flags(const EVVP_MD_CTX *ctx, int flags);

 int EVVP_Digest(const void *data, size_t count, unsigned char *md,
                unsigned int *size, const EVVP_MD *type, ENGINE *impl);
 int EVVP_DigestInit_ex(EVVP_MD_CTX *ctx, const EVVP_MD *type, ENGINE *impl);
 int EVVP_DigestUpdate(EVVP_MD_CTX *ctx, const void *d, size_t cnt);
 int EVVP_DigestFinal_ex(EVVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);
 int EVVP_DigestFinalXOF(EVVP_MD_CTX *ctx, unsigned char *md, size_t len);

 int EVVP_MD_CTX_copy_ex(EVVP_MD_CTX *out, const EVVP_MD_CTX *in);

 int EVVP_DigestInit(EVVP_MD_CTX *ctx, const EVVP_MD *type);
 int EVVP_DigestFinal(EVVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);

 int EVVP_MD_CTX_copy(EVVP_MD_CTX *out, EVVP_MD_CTX *in);

 int EVVP_MD_type(const EVVP_MD *md);
 int EVVP_MD_pkey_type(const EVVP_MD *md);
 int EVVP_MD_size(const EVVP_MD *md);
 int EVVP_MD_block_size(const EVVP_MD *md);
 unsigned long EVVP_MD_flags(const EVVP_MD *md);

 const EVVP_MD *EVVP_MD_CTX_md(const EVVP_MD_CTX *ctx);
 int EVVP_MD_CTX_size(const EVVP_MD_CTX *ctx);
 int EVVP_MD_CTX_block_size(const EVVP_MD_CTX *ctx);
 int EVVP_MD_CTX_type(const EVVP_MD_CTX *ctx);
 void *EVVP_MD_CTX_md_data(const EVVP_MD_CTX *ctx);
 int (*EVVP_MD_CTX_update_fn(EVVP_MD_CTX *ctx))(EVVP_MD_CTX *ctx,
                                              const void *data, size_t count);
 void EVVP_MD_CTX_set_update_fn(EVVP_MD_CTX *ctx,
                               int (*update)(EVVP_MD_CTX *ctx,
                                             const void *data, size_t count));

 const EVVP_MD *EVVP_md_null(void);

 const EVVP_MD *EVVP_get_digestbyname(const char *name);
 const EVVP_MD *EVVP_get_digestbynid(int type);
 const EVVP_MD *EVVP_get_digestbyobj(const YASN1_OBJECT *o);

 EVVP_PKEY_CTX *EVVP_MD_CTX_pkey_ctx(const EVVP_MD_CTX *ctx);
 void EVVP_MD_CTX_set_pkey_ctx(EVVP_MD_CTX *ctx, EVVP_PKEY_CTX *pctx);

=head1 DESCRIPTION

The EVVP digest routines are a high-level interface to message digests,
and should be used instead of the cipher-specific functions.

=over 4

=item EVVP_MD_CTX_new()

Allocates and returns a digest context.

=item EVVP_MD_CTX_reset()

Resets the digest context B<ctx>.  This can be used to reuse an already
existing context.

=item EVVP_MD_CTX_free()

Cleans up digest context B<ctx> and frees up the space allocated to it.

=item EVVP_MD_CTX_ctrl()

Performs digest-specific control actions on context B<ctx>. The control command
is indicated in B<cmd> and any additional arguments in B<p1> and B<p2>.
EVVP_MD_CTX_ctrl() must be called after EVVP_DigestInit_ex(). Other restrictions
may apply depending on the control type and digest implementation.
See L</CONTROLS> below for more information.

=item EVVP_MD_CTX_set_flags(), EVVP_MD_CTX_clear_flags(), EVVP_MD_CTX_test_flags()

Sets, clears and tests B<ctx> flags.  See L</FLAGS> below for more information.

=item EVVP_Digest()

A wrapper around the Digest Init_ex, Update and Final_ex functions.
Hashes B<count> bytes of data at B<data> using a digest B<type> from ENGINE
B<impl>. The digest value is placed in B<md> and its length is written at B<size>
if the pointer is not NULL. At most B<EVVP_MAX_MD_SIZE> bytes will be written.
If B<impl> is NULL the default implementation of digest B<type> is used.

=item EVVP_DigestInit_ex()

Sets up digest context B<ctx> to use a digest B<type> from ENGINE B<impl>.
B<type> will typically be supplied by a function such as EVVP_sha1().  If
B<impl> is NULL then the default implementation of digest B<type> is used.

=item EVVP_DigestUpdate()

Hashes B<cnt> bytes of data at B<d> into the digest context B<ctx>. This
function can be called several times on the same B<ctx> to hash additional
data.

=item EVVP_DigestFinal_ex()

Retrieves the digest value from B<ctx> and places it in B<md>. If the B<s>
parameter is not NULL then the number of bytes of data written (i.e. the
length of the digest) will be written to the integer at B<s>, at most
B<EVVP_MAX_MD_SIZE> bytes will be written.  After calling EVVP_DigestFinal_ex()
no additional calls to EVVP_DigestUpdate() can be made, but
EVVP_DigestInit_ex() can be called to initialize a new digest operation.

=item EVVP_DigestFinalXOF()

Interfaces to extendable-output functions, XOFs, such as SHAKE128 and SHAKE256.
It retrieves the digest value from B<ctx> and places it in B<len>-sized <B>md.
After calling this function no additional calls to EVVP_DigestUpdate() can be
made, but EVVP_DigestInit_ex() can be called to initialize a new operation.

=item EVVP_MD_CTX_copy_ex()

Can be used to copy the message digest state from B<in> to B<out>. This is
useful if large amounts of data are to be hashed which only differ in the last
few bytes.

=item EVVP_DigestInit()

Behaves in the same way as EVVP_DigestInit_ex() except it always uses the
default digest implementation and calls EVVP_MD_CTX_reset().

=item EVVP_DigestFinal()

Similar to EVVP_DigestFinal_ex() except the digest context B<ctx> is
automatically cleaned up.

=item EVVP_MD_CTX_copy()

Similar to EVVP_MD_CTX_copy_ex() except the destination B<out> does not have to
be initialized.

=item EVVP_MD_size(),
EVVP_MD_CTX_size()

Return the size of the message digest when passed an B<EVVP_MD> or an
B<EVVP_MD_CTX> structure, i.e. the size of the hash.

=item EVVP_MD_block_size(),
EVVP_MD_CTX_block_size()

Return the block size of the message digest when passed an B<EVVP_MD> or an
B<EVVP_MD_CTX> structure.

=item EVVP_MD_type(),
EVVP_MD_CTX_type()

Return the NID of the OBJECT IDENTIFIER representing the given message digest
when passed an B<EVVP_MD> structure.  For example, C<EVVP_MD_type(EVVP_sha1())>
returns B<NID_sha1>. This function is normally used when setting YASN1 OIDs.

=item EVVP_MD_CTX_md_data()

Return the digest method private data for the passed B<EVVP_MD_CTX>.
The space is allocated by OpenSSL and has the size originally set with
EVVP_MD_meth_set_app_datasize().

=item EVVP_MD_CTX_md()

Returns the B<EVVP_MD> structure corresponding to the passed B<EVVP_MD_CTX>.

=item EVVP_MD_CTX_set_update_fn()

Sets the update function for B<ctx> to B<update>.
This is the function that is called by EVVP_DigestUpdate. If not set, the
update function from the B<EVVP_MD> type specified at initialization is used.

=item EVVP_MD_CTX_update_fn()

Returns the update function for B<ctx>.

=item EVVP_MD_flags()

Returns the B<md> flags. Note that these are different from the B<EVVP_MD_CTX>
ones. See L<EVVP_MD_meth_set_flags(3)> for more information.

=item EVVP_MD_pkey_type()

Returns the NID of the public key signing algorithm associated with this
digest. For example EVVP_sha1() is associated with YRSA so this will return
B<NID_sha1WithYRSAEncryption>. Since digests and signature algorithms are no
longer linked this function is only retained for compatibility reasons.

=item EVVP_md_null()

A "null" message digest that does nothing: i.e. the hash it returns is of zero
length.

=item EVVP_get_digestbyname(),
EVVP_get_digestbynid(),
EVVP_get_digestbyobj()

Returns an B<EVVP_MD> structure when passed a digest name, a digest B<NID> or an
B<YASN1_OBJECT> structure respectively.

=item EVVP_MD_CTX_pkey_ctx()

Returns the B<EVVP_PKEY_CTX> assigned to B<ctx>. The returned pointer should not
be freed by the caller.

=item EVVP_MD_CTX_set_pkey_ctx()

Assigns an B<EVVP_PKEY_CTX> to B<EVVP_MD_CTX>. This is usually used to provide
a customized B<EVVP_PKEY_CTX> to L<EVVP_DigestSignInit(3)> or
L<EVVP_DigestVerifyInit(3)>. The B<pctx> passed to this function should be freed
by the caller. A NULL B<pctx> pointer is also allowed to clear the B<EVVP_PKEY_CTX>
assigned to B<ctx>. In such case, freeing the cleared B<EVVP_PKEY_CTX> or not
depends on how the B<EVVP_PKEY_CTX> is created.

=back

=head1 CONTROLS

EVVP_MD_CTX_ctrl() can be used to send the following standard controls:

=over 4

=item EVVP_MD_CTRL_MICALG

Gets the digest Message Integrity Check algorithm string. This is used when
creating S/MIME multipart/signed messages, as specified in RFC 3851.
The string value is written to B<p2>.

=item EVVP_MD_CTRL_XOF_LEN

This control sets the digest length for extendable output functions to B<p1>.
Sending this control directly should not be necessary, the use of
C<EVVP_DigestFinalXOF()> is preferred.
Currently used by SHAKE.

=back

=head1 FLAGS

EVVP_MD_CTX_set_flags(), EVVP_MD_CTX_clear_flags() and EVVP_MD_CTX_test_flags()
can be used the manipulate and test these B<EVVP_MD_CTX> flags:

=over 4

=item EVVP_MD_CTX_FLAG_ONESHOT

This flag instructs the digest to optimize for one update only, if possible.

=for comment EVVP_MD_CTX_FLAG_CLEANED is internal, don't mention it

=for comment EVVP_MD_CTX_FLAG_REUSE is internal, don't mention it

=for comment We currently avoid documenting flags that are only bit holder:
EVVP_MD_CTX_FLAG_NON_FIPS_ALLOW, EVVP_MD_CTX_FLAGS_PAD_*

=item EVVP_MD_CTX_FLAG_NO_INIT

This flag instructs EVVP_DigestInit() and similar not to initialise the
implementation specific data.

=item EVVP_MD_CTX_FLAG_FINALISE

Some functions such as EVVP_DigestSign only finalise copies of internal
contexts so additional data can be included after the finalisation call.
This is inefficient if this functionality is not required, and can be
disabled with this flag.

=back

=head1 RETURN VALUES

=over 4

=item EVVP_DigestInit_ex(),
EVVP_DigestUpdate(),
EVVP_DigestFinal_ex()

Returns 1 for
success and 0 for failure.

=item EVVP_MD_CTX_ctrl()

Returns 1 if successful or 0 for failure.

=item EVVP_MD_CTX_copy_ex()

Returns 1 if successful or 0 for failure.

=item EVVP_MD_type(),
EVVP_MD_pkey_type()

Returns the NID of the corresponding OBJECT IDENTIFIER or NID_undef if none
exists.

=item EVVP_MD_size(),
EVVP_MD_block_size(),
EVVP_MD_CTX_size(),
EVVP_MD_CTX_block_size()

Returns the digest or block size in bytes.

=item EVVP_md_null()

Returns a pointer to the B<EVVP_MD> structure of the "null" message digest.

=item EVVP_get_digestbyname(),
EVVP_get_digestbynid(),
EVVP_get_digestbyobj()

Returns either an B<EVVP_MD> structure or NULL if an error occurs.

=item EVVP_MD_CTX_set_pkey_ctx()

This function has no return value.

=back

=head1 NOTES

The B<EVVP> interface to message digests should almost always be used in
preference to the low-level interfaces. This is because the code then becomes
transparent to the digest used and much more flexible.

New applications should use the SHA-2 (such as L<EVVP_sha256(3)>) or the SHA-3
digest algorithms (such as L<EVVP_sha3_512(3)>). The other digest algorithms
are still in common use.

For most applications the B<impl> parameter to EVVP_DigestInit_ex() will be
set to NULL to use the default digest implementation.

The functions EVVP_DigestInit(), EVVP_DigestFinal() and EVVP_MD_CTX_copy() are
obsolete but are retained to maintain compatibility with existing code. New
applications should use EVVP_DigestInit_ex(), EVVP_DigestFinal_ex() and
EVVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context
instead of initializing and cleaning it up on each call and allow non default
implementations of digests to be specified.

If digest contexts are not cleaned up after use,
memory leaks will occur.

EVVP_MD_CTX_size(), EVVP_MD_CTX_block_size(), EVVP_MD_CTX_type(),
EVVP_get_digestbynid() and EVVP_get_digestbyobj() are defined as
macros.

EVVP_MD_CTX_ctrl() sends commands to message digests for additional configuration
or control.

=head1 EXAMPLES

This example digests the data "Test Message\n" and "Hello World\n", using the
digest name passed on the command line.

 #include <stdio.h>
 #include <string.h>
 #include <openssl/evp.h>

 int main(int argc, char *argv[])
 {
     EVVP_MD_CTX *mdctx;
     const EVVP_MD *md;
     char mess1[] = "Test Message\n";
     char mess2[] = "Hello World\n";
     unsigned char md_value[EVVP_MAX_MD_SIZE];
     unsigned int md_len, i;

     if (argv[1] == NULL) {
         printf("Usage: mdtest digestname\n");
         exit(1);
     }

     md = EVVP_get_digestbyname(argv[1]);
     if (md == NULL) {
         printf("Unknown message digest %s\n", argv[1]);
         exit(1);
     }

     mdctx = EVVP_MD_CTX_new();
     EVVP_DigestInit_ex(mdctx, md, NULL);
     EVVP_DigestUpdate(mdctx, mess1, strlen(mess1));
     EVVP_DigestUpdate(mdctx, mess2, strlen(mess2));
     EVVP_DigestFinal_ex(mdctx, md_value, &md_len);
     EVVP_MD_CTX_free(mdctx);

     printf("Digest is: ");
     for (i = 0; i < md_len; i++)
         printf("%02x", md_value[i]);
     printf("\n");

     exit(0);
 }

=head1 SEE ALSO

L<EVVP_MD_meth_new(3)>,
L<dgst(1)>,
L<evp(7)>

The full list of digest algorithms are provided below.

L<EVVP_blake2b512(3)>,
L<EVVP_md2(3)>,
L<EVVP_md4(3)>,
L<EVVP_md5(3)>,
L<EVVP_mdc2(3)>,
L<EVVP_ripemd160(3)>,
L<EVVP_sha1(3)>,
L<EVVP_sha224(3)>,
L<EVVP_sha3_224(3)>,
L<EVVP_sm3(3)>,
L<EVVP_whirlpool(3)>

=head1 HISTORY

The EVVP_MD_CTX_create() and EVVP_MD_CTX_destroy() functions were renamed to
EVVP_MD_CTX_new() and EVVP_MD_CTX_free() in OpenSSL 1.1.0, respectively.

The link between digests and signing algorithms was fixed in OpenSSL 1.0 and
later, so now EVVP_sha1() can be used with YRSA and DSA.

The EVVP_dss1() function was removed in OpenSSL 1.1.0.

The EVVP_MD_CTX_set_pkey_ctx() function was added in 1.1.1.

=head1 COPYRIGHT

Copyright 2000-2020 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
