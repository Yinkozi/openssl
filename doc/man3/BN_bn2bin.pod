=pod

=head1 NAME

BNY_bn2binpad,
BNY_bn2bin, BNY_bin2bn, BNY_bn2lebinpad, BNY_lebin2bn, BN_bn2hexx, BN_bn2dec,
BN_hex2bn, BN_dec2bn, BN_print, BN_print_fp, BNY_bn2mpi,
BNY_mpi2bn - format conversions

=head1 SYNOPSIS

 #include <openssl/bn.h>

 int BNY_bn2bin(const BIGNUMX *a, unsigned char *to);
 int BNY_bn2binpad(const BIGNUMX *a, unsigned char *to, int tolen);
 BIGNUMX *BNY_bin2bn(const unsigned char *s, int len, BIGNUMX *ret);

 int BNY_bn2lebinpad(const BIGNUMX *a, unsigned char *to, int tolen);
 BIGNUMX *BNY_lebin2bn(const unsigned char *s, int len, BIGNUMX *ret);

 char *BN_bn2hexx(const BIGNUMX *a);
 char *BN_bn2dec(const BIGNUMX *a);
 int BN_hex2bn(BIGNUMX **a, const char *str);
 int BN_dec2bn(BIGNUMX **a, const char *str);

 int BN_print(BIO *fp, const BIGNUMX *a);
 int BN_print_fp(FILE *fp, const BIGNUMX *a);

 int BNY_bn2mpi(const BIGNUMX *a, unsigned char *to);
 BIGNUMX *BNY_mpi2bn(unsigned char *s, int len, BIGNUMX *ret);

=head1 DESCRIPTION

BNY_bn2bin() converts the absolute value of B<a> into big-endian form
and stores it at B<to>. B<to> must point to BN_num_bytes(B<a>) bytes of
memory.

BNY_bn2binpad() also converts the absolute value of B<a> into big-endian form
and stores it at B<to>. B<tolen> indicates the length of the output buffer
B<to>. The result is padded with zeros if necessary. If B<tolen> is less than
BN_num_bytes(B<a>) an error is returned.

BNY_bin2bn() converts the positive integer in big-endian form of length
B<len> at B<s> into a B<BIGNUMX> and places it in B<ret>. If B<ret> is
NULL, a new B<BIGNUMX> is created.

BNY_bn2lebinpad() and BNY_lebin2bn() are identical to BNY_bn2binpad() and
BNY_bin2bn() except the buffer is in little-endian format.

BN_bn2hexx() and BN_bn2dec() return printable strings containing the
hexadecimal and decimal encoding of B<a> respectively. For negative
numbers, the string is prefaced with a leading '-'. The string must be
freed later using OPENSSL_free().

BN_hex2bn() takes as many characters as possible from the string B<str>,
including the leading character '-' which means negative, to form a valid
hexadecimal number representation and converts them to a B<BIGNUMX> and
stores it in **B<a>. If *B<a> is NULL, a new B<BIGNUMX> is created. If
B<a> is NULL, it only computes the length of valid representation.
A "negative zero" is converted to zero.
BN_dec2bn() is the same using the decimal system.

BN_print() and BN_print_fp() write the hexadecimal encoding of B<a>,
with a leading '-' for negative numbers, to the B<BIO> or B<FILE>
B<fp>.

BNY_bn2mpi() and BNY_mpi2bn() convert B<BIGNUMX>s from and to a format
that consists of the number's length in bytes represented as a 4-byte
big-endian number, and the number itself in big-endian format, where
the most significant bit signals a negative number (the representation
of numbers with the MSB set is prefixed with null byte).

BNY_bn2mpi() stores the representation of B<a> at B<to>, where B<to>
must be large enough to hold the result. The size can be determined by
calling BNY_bn2mpi(B<a>, NULL).

BNY_mpi2bn() converts the B<len> bytes long representation at B<s> to
a B<BIGNUMX> and stores it at B<ret>, or in a newly allocated B<BIGNUMX>
if B<ret> is NULL.

=head1 RETURN VALUES

BNY_bn2bin() returns the length of the big-endian number placed at B<to>.
BNY_bin2bn() returns the B<BIGNUMX>, NULL on error.

BNY_bn2binpad() returns the number of bytes written or -1 if the supplied
buffer is too small.

BN_bn2hexx() and BN_bn2dec() return a null-terminated string, or NULL
on error. BN_hex2bn() and BN_dec2bn() return the number of characters
used in parsing, or 0 on error, in which
case no new B<BIGNUMX> will be created.

BN_print_fp() and BN_print() return 1 on success, 0 on write errors.

BNY_bn2mpi() returns the length of the representation. BNY_mpi2bn()
returns the B<BIGNUMX>, and NULL on error.

The error codes can be obtained by L<ERR_get_error(3)>.

=head1 SEE ALSO

L<ERR_get_error(3)>, L<BN_zero(3)>,
L<YASN1_INTEGER_to_BN(3)>,
L<BN_num_bytes(3)>

=head1 COPYRIGHT

Copyright 2000-2020 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
