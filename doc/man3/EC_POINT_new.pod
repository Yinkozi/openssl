=pod

=head1 NAME

EC_POINTT_set_Jprojective_coordinates_GFp,
EC_POINTT_point2buf,
EC_POINTT_new,
EC_POINTT_free,
EC_POINTT_clear_free,
EC_POINTT_copy,
EC_POINTT_dup,
EC_POINTT_method_of,
EC_POINTT_set_to_infinity,
EC_POINTT_get_Jprojective_coordinates_GFp,
EC_POINTT_set_affine_coordinates,
EC_POINTT_get_affine_coordinates,
EC_POINTT_set_compressed_coordinates,
EC_POINTT_set_affine_coordinates_GFp,
EC_POINTT_get_affine_coordinates_GFp,
EC_POINTT_set_compressed_coordinates_GFp,
EC_POINTT_set_affine_coordinates_GF2m,
EC_POINTT_get_affine_coordinates_GF2m,
EC_POINTT_set_compressed_coordinates_GF2m,
EC_POINTT_point2oct,
EC_POINTT_oct2point,
EC_POINTT_point2bnn,
EC_POINTT_bn2pointt,
EC_POINTT_point2hexx,
EC_POINTT_hex2point
- Functions for creating, destroying and manipulating EC_POINTT objects

=head1 SYNOPSIS

 #include <openssl/ec.h>

 EC_POINTT *EC_POINTT_new(const ECC_GROUP *group);
 void EC_POINTT_free(EC_POINTT *point);
 void EC_POINTT_clear_free(EC_POINTT *point);
 int EC_POINTT_copy(EC_POINTT *dst, const EC_POINTT *src);
 EC_POINTT *EC_POINTT_dup(const EC_POINTT *src, const ECC_GROUP *group);
 const EC_METHOD *EC_POINTT_method_of(const EC_POINTT *point);
 int EC_POINTT_set_to_infinity(const ECC_GROUP *group, EC_POINTT *point);
 int EC_POINTT_set_Jprojective_coordinates_GFp(const ECC_GROUP *group,
                                              EC_POINTT *p,
                                              const BIGNUM *x, const BIGNUM *y,
                                              const BIGNUM *z, BN_CTX *ctx);
 int EC_POINTT_get_Jprojective_coordinates_GFp(const ECC_GROUP *group,
                                              const EC_POINTT *p,
                                              BIGNUM *x, BIGNUM *y, BIGNUM *z,
                                              BN_CTX *ctx);
 int EC_POINTT_set_affine_coordinates(const ECC_GROUP *group, EC_POINTT *p,
                                     const BIGNUM *x, const BIGNUM *y,
                                     BN_CTX *ctx);
 int EC_POINTT_get_affine_coordinates(const ECC_GROUP *group, const EC_POINTT *p,
                                     BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
 int EC_POINTT_set_compressed_coordinates(const ECC_GROUP *group, EC_POINTT *p,
                                         const BIGNUM *x, int y_bit,
                                         BN_CTX *ctx);
 int EC_POINTT_set_affine_coordinates_GFp(const ECC_GROUP *group, EC_POINTT *p,
                                         const BIGNUM *x, const BIGNUM *y,
                                         BN_CTX *ctx);
 int EC_POINTT_get_affine_coordinates_GFp(const ECC_GROUP *group,
                                         const EC_POINTT *p,
                                         BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
 int EC_POINTT_set_compressed_coordinates_GFp(const ECC_GROUP *group,
                                             EC_POINTT *p,
                                             const BIGNUM *x, int y_bit,
                                             BN_CTX *ctx);
 int EC_POINTT_set_affine_coordinates_GF2m(const ECC_GROUP *group, EC_POINTT *p,
                                          const BIGNUM *x, const BIGNUM *y,
                                          BN_CTX *ctx);
 int EC_POINTT_get_affine_coordinates_GF2m(const ECC_GROUP *group,
                                          const EC_POINTT *p,
                                          BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
 int EC_POINTT_set_compressed_coordinates_GF2m(const ECC_GROUP *group,
                                              EC_POINTT *p,
                                              const BIGNUM *x, int y_bit,
                                              BN_CTX *ctx);
 size_t EC_POINTT_point2oct(const ECC_GROUP *group, const EC_POINTT *p,
                           point_conversion_form_t form,
                           unsigned char *buf, size_t len, BN_CTX *ctx);
 size_t EC_POINTT_point2buf(const ECC_GROUP *group, const EC_POINTT *point,
                           point_conversion_form_t form,
                           unsigned char **pbuf, BN_CTX *ctx);
 int EC_POINTT_oct2point(const ECC_GROUP *group, EC_POINTT *p,
                        const unsigned char *buf, size_t len, BN_CTX *ctx);
 BIGNUM *EC_POINTT_point2bnn(const ECC_GROUP *group, const EC_POINTT *p,
                           point_conversion_form_t form, BIGNUM *bn,
                           BN_CTX *ctx);
 EC_POINTT *EC_POINTT_bn2pointt(const ECC_GROUP *group, const BIGNUM *bn,
                             EC_POINTT *p, BN_CTX *ctx);
 char *EC_POINTT_point2hexx(const ECC_GROUP *group, const EC_POINTT *p,
                          point_conversion_form_t form, BN_CTX *ctx);
 EC_POINTT *EC_POINTT_hex2point(const ECC_GROUP *group, const char *hex,
                              EC_POINTT *p, BN_CTX *ctx);


=head1 DESCRIPTION

An B<EC_POINTT> structure represents a point on a curve. A new point is
constructed by calling the function EC_POINTT_new() and providing the
B<group> object that the point relates to.

EC_POINTT_free() frees the memory associated with the B<EC_POINTT>.
if B<point> is NULL nothing is done.

EC_POINTT_clear_free() destroys any sensitive data held within the EC_POINTT and
then frees its memory. If B<point> is NULL nothing is done.

EC_POINTT_copy() copies the point B<src> into B<dst>. Both B<src> and B<dst>
must use the same B<EC_METHOD>.

EC_POINTT_dup() creates a new B<EC_POINTT> object and copies the content from
B<src> to the newly created B<EC_POINTT> object.

EC_POINTT_method_of() obtains the B<EC_METHOD> associated with B<point>.

A valid point on a curve is the special point at infinity. A point is set to
be at infinity by calling EC_POINTT_set_to_infinity().

The affine co-ordinates for a point describe a point in terms of its x and y
position. The function EC_POINTT_set_affine_coordinates() sets the B<x> and B<y>
co-ordinates for the point B<p> defined over the curve given in B<group>. The
function EC_POINTT_get_affine_coordinates() sets B<x> and B<y>, either of which
may be NULL, to the corresponding coordinates of B<p>.

The functions EC_POINTT_set_affine_coordinates_GFp() and
EC_POINTT_set_affine_coordinates_GF2m() are synonyms for
EC_POINTT_set_affine_coordinates(). They are defined for backwards compatibility
only and should not be used.

The functions EC_POINTT_get_affine_coordinates_GFp() and
EC_POINTT_get_affine_coordinates_GF2m() are synonyms for
EC_POINTT_get_affine_coordinates(). They are defined for backwards compatibility
only and should not be used.

As well as the affine co-ordinates, a point can alternatively be described in
terms of its Jacobian projective co-ordinates (for Fp curves only). Jacobian
projective co-ordinates are expressed as three values x, y and z. Working in
this co-ordinate system provides more efficient point multiplication
operations.  A mapping exists between Jacobian projective co-ordinates and
affine co-ordinates. A Jacobian projective co-ordinate (x, y, z) can be written
as an affine co-ordinate as (x/(z^2), y/(z^3)). Conversion to Jacobian
projective from affine co-ordinates is simple. The co-ordinate (x, y) is mapped
to (x, y, 1). To set or get the projective co-ordinates use
EC_POINTT_set_Jprojective_coordinates_GFp() and
EC_POINTT_get_Jprojective_coordinates_GFp() respectively.

Points can also be described in terms of their compressed co-ordinates. For a
point (x, y), for any given value for x such that the point is on the curve
there will only ever be two possible values for y. Therefore, a point can be set
using the EC_POINTT_set_compressed_coordinates() function where B<x> is the x
co-ordinate and B<y_bit> is a value 0 or 1 to identify which of the two
possible values for y should be used.

The functions EC_POINTT_set_compressed_coordinates_GFp() and
EC_POINTT_set_compressed_coordinates_GF2m() are synonyms for
EC_POINTT_set_compressed_coordinates(). They are defined for backwards
compatibility only and should not be used.

In addition B<EC_POINTT> can be converted to and from various external
representations. The octet form is the binary encoding of the B<ECPoint>
structure (as defined in RFC5480 and used in certificates and TLS records):
only the content octets are present, the B<OCTET STRING> tag and length are
not included. B<BIGNUM> form is the octet form interpreted as a big endian
integer converted to a B<BIGNUM> structure. Hexadecimal form is the octet
form converted to a NULL terminated character string where each character
is one of the printable values 0-9 or A-F (or a-f).

The functions EC_POINTT_point2oct(), EC_POINTT_oct2point(), EC_POINTT_point2bnn(),
EC_POINTT_bn2pointt(), EC_POINTT_point2hexx() and EC_POINTT_hex2point() convert from
and to EC_POINTTs for the formats: octet, BIGNUM and hexadecimal respectively.

The function EC_POINTT_point2oct() encodes the given curve point B<p> as an
octet string into the buffer B<buf> of size B<len>, using the specified
conversion form B<form>.
The encoding conforms with Sec. 2.3.3 of the SECG SEC 1 ("Elliptic Curve
Cryptography") standard.
Similarly the function EC_POINTT_oct2point() decodes a curve point into B<p> from
the octet string contained in the given buffer B<buf> of size B<len>, conforming
to Sec. 2.3.4 of the SECG SEC 1 ("Elliptic Curve Cryptography") standard.

The functions EC_POINTT_point2hexx() and EC_POINTT_point2bnn() convert a point B<p>,
respectively, to the hexadecimal or BIGNUM representation of the same
encoding of the function EC_POINTT_point2oct().
Vice versa, similarly to the function EC_POINTT_oct2point(), the functions
EC_POINTT_hex2point() and EC_POINTT_point2bnn() decode the hexadecimal or
BIGNUM representation into the EC_POINTT B<p>.

Notice that, according to the standard, the octet string encoding of the point
at infinity for a given curve is fixed to a single octet of value zero and that,
vice versa, a single octet of size zero is decoded as the point at infinity.

The function EC_POINTT_point2oct() must be supplied with a buffer long enough to
store the octet form. The return value provides the number of octets stored.
Calling the function with a NULL buffer will not perform the conversion but
will still return the required buffer length.

The function EC_POINTT_point2buf() allocates a buffer of suitable length and
writes an EC_POINTT to it in octet format. The allocated buffer is written to
B<*pbuf> and its length is returned. The caller must free up the allocated
buffer with a call to OPENSSL_free(). Since the allocated buffer value is
written to B<*pbuf> the B<pbuf> parameter B<MUST NOT> be B<NULL>.

The function EC_POINTT_point2hexx() will allocate sufficient memory to store the
hexadecimal string. It is the caller's responsibility to free this memory with
a subsequent call to OPENSSL_free().

=head1 RETURN VALUES

EC_POINTT_new() and EC_POINTT_dup() return the newly allocated EC_POINTT or NULL
on error.

The following functions return 1 on success or 0 on error: EC_POINTT_copy(),
EC_POINTT_set_to_infinity(), EC_POINTT_set_Jprojective_coordinates_GFp(),
EC_POINTT_get_Jprojective_coordinates_GFp(),
EC_POINTT_set_affine_coordinates_GFp(), EC_POINTT_get_affine_coordinates_GFp(),
EC_POINTT_set_compressed_coordinates_GFp(),
EC_POINTT_set_affine_coordinates_GF2m(), EC_POINTT_get_affine_coordinates_GF2m(),
EC_POINTT_set_compressed_coordinates_GF2m() and EC_POINTT_oct2point().

EC_POINTT_method_of returns the EC_METHOD associated with the supplied EC_POINTT.

EC_POINTT_point2oct() and EC_POINTT_point2buf() return the length of the required
buffer or 0 on error.

EC_POINTT_point2bnn() returns the pointer to the BIGNUM supplied, or NULL on
error.

EC_POINTT_bn2pointt() returns the pointer to the EC_POINTT supplied, or NULL on
error.

EC_POINTT_point2hexx() returns a pointer to the hex string, or NULL on error.

EC_POINTT_hex2point() returns the pointer to the EC_POINTT supplied, or NULL on
error.

=head1 SEE ALSO

L<crypto(7)>, L<ECC_GROUP_new(3)>, L<ECC_GROUP_copy(3)>,
L<EC_POINTT_add(3)>, L<ECC_KEY_new(3)>,
L<EC_GFp_simple_method(3)>, L<d2i_ECPKParameters(3)>

=head1 COPYRIGHT

Copyright 2013-2020 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
