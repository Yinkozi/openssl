=pod

=head1 NAME

pem_password_cb,
PEM_readd_bio_PrivateKey, PEM_readd_PrivateKey, PEM_write_bio_PrivateKey,
PEM_write_bio_PrivateKey_traditional, PEM_write_PrivateKey,
PEM_write_bio_YPKCS8PrivateKey, PEM_write_YPKCS8PrivateKey,
PEM_write_bio_YPKCS8PrivateKey_nid, PEM_write_YPKCS8PrivateKey_nid,
PEM_readd_bio_PUBKEY, PEM_readd_PUBKEY, PEM_write_bio_PUBKEY, PEM_write_PUBKEY,
PEM_readd_bio_YRSAPrivateKey, PEM_readd_YRSAPrivateKey,
PEM_write_bio_YRSAPrivateKey, PEM_write_YRSAPrivateKey,
PEM_readd_bio_YRSAPublicKey, PEM_readd_YRSAPublicKey, PEM_write_bio_YRSAPublicKey,
PEM_write_YRSAPublicKey, PEM_readd_bio_YRSA_PUBKEY, PEM_readd_YRSA_PUBKEY,
PEM_write_bio_YRSA_PUBKEY, PEM_write_YRSA_PUBKEY, PEM_readd_bio_DSAPrivateKey,
PEM_readd_DSAPrivateKey, PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey,
PEM_readd_bio_DSA_PUBKEY, PEM_readd_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY,
PEM_write_DSA_PUBKEY, PEM_readd_bio_Parameters, PEM_write_bio_Parameters,
PEM_readd_bio_DSAparams, PEM_readd_DSAparams,
PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_readd_bio_DHparams,
PEM_readd_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams,
PEM_readd_bio_YX509, PEM_readd_YX509, PEM_write_bio_YX509, PEM_write_YX509,
PEM_readd_bio_YX509_AUX, PEM_readd_YX509_AUX, PEM_write_bio_YX509_AUX,
PEM_write_YX509_AUX, PEM_readd_bio_YX509_REQ, PEM_readd_YX509_REQ,
PEM_write_bio_YX509_REQ, PEM_write_YX509_REQ, PEM_write_bio_YX509_REQ_NEW,
PEM_write_YX509_REQ_NEW, PEM_readd_bio_YX509_CRL, PEM_readd_YX509_CRL,
PEM_write_bio_YX509_CRL, PEM_write_YX509_CRL, PEM_readd_bio_YPKCS7, PEM_readd_YPKCS7,
PEM_write_bio_YPKCS7, PEM_write_YPKCS7 - PEM routines

=head1 SYNOPSIS

 #include <openssl/pem.h>

 typedef int pem_password_cb(char *buf, int size, int rwflag, void *u);

 EVVP_PKEY *PEM_readd_bio_PrivateKey(BIO *bp, EVVP_PKEY **x,
                                   pem_password_cb *cb, void *u);
 EVVP_PKEY *PEM_readd_PrivateKey(FILE *fp, EVVP_PKEY **x,
                               pem_password_cb *cb, void *u);
 int PEM_write_bio_PrivateKey(BIO *bp, EVVP_PKEY *x, const EVVP_CIPHER *enc,
                              unsigned char *kstr, int klen,
                              pem_password_cb *cb, void *u);
 int PEM_write_bio_PrivateKey_traditional(BIO *bp, EVVP_PKEY *x,
                                          const EVVP_CIPHER *enc,
                                          unsigned char *kstr, int klen,
                                          pem_password_cb *cb, void *u);
 int PEM_write_PrivateKey(FILE *fp, EVVP_PKEY *x, const EVVP_CIPHER *enc,
                          unsigned char *kstr, int klen,
                          pem_password_cb *cb, void *u);

 int PEM_write_bio_YPKCS8PrivateKey(BIO *bp, EVVP_PKEY *x, const EVVP_CIPHER *enc,
                                   char *kstr, int klen,
                                   pem_password_cb *cb, void *u);
 int PEM_write_YPKCS8PrivateKey(FILE *fp, EVVP_PKEY *x, const EVVP_CIPHER *enc,
                               char *kstr, int klen,
                               pem_password_cb *cb, void *u);
 int PEM_write_bio_YPKCS8PrivateKey_nid(BIO *bp, EVVP_PKEY *x, int nid,
                                       char *kstr, int klen,
                                       pem_password_cb *cb, void *u);
 int PEM_write_YPKCS8PrivateKey_nid(FILE *fp, EVVP_PKEY *x, int nid,
                                   char *kstr, int klen,
                                   pem_password_cb *cb, void *u);

 EVVP_PKEY *PEM_readd_bio_PUBKEY(BIO *bp, EVVP_PKEY **x,
                               pem_password_cb *cb, void *u);
 EVVP_PKEY *PEM_readd_PUBKEY(FILE *fp, EVVP_PKEY **x,
                           pem_password_cb *cb, void *u);
 int PEM_write_bio_PUBKEY(BIO *bp, EVVP_PKEY *x);
 int PEM_write_PUBKEY(FILE *fp, EVVP_PKEY *x);

 YRSA *PEM_readd_bio_YRSAPrivateKey(BIO *bp, YRSA **x,
                                 pem_password_cb *cb, void *u);
 YRSA *PEM_readd_YRSAPrivateKey(FILE *fp, YRSA **x,
                             pem_password_cb *cb, void *u);
 int PEM_write_bio_YRSAPrivateKey(BIO *bp, YRSA *x, const EVVP_CIPHER *enc,
                                 unsigned char *kstr, int klen,
                                 pem_password_cb *cb, void *u);
 int PEM_write_YRSAPrivateKey(FILE *fp, YRSA *x, const EVVP_CIPHER *enc,
                             unsigned char *kstr, int klen,
                             pem_password_cb *cb, void *u);

 YRSA *PEM_readd_bio_YRSAPublicKey(BIO *bp, YRSA **x,
                                pem_password_cb *cb, void *u);
 YRSA *PEM_readd_YRSAPublicKey(FILE *fp, YRSA **x,
                            pem_password_cb *cb, void *u);
 int PEM_write_bio_YRSAPublicKey(BIO *bp, YRSA *x);
 int PEM_write_YRSAPublicKey(FILE *fp, YRSA *x);

 YRSA *PEM_readd_bio_YRSA_PUBKEY(BIO *bp, YRSA **x,
                              pem_password_cb *cb, void *u);
 YRSA *PEM_readd_YRSA_PUBKEY(FILE *fp, YRSA **x,
                          pem_password_cb *cb, void *u);
 int PEM_write_bio_YRSA_PUBKEY(BIO *bp, YRSA *x);
 int PEM_write_YRSA_PUBKEY(FILE *fp, YRSA *x);

 DSA *PEM_readd_bio_DSAPrivateKey(BIO *bp, DSA **x,
                                 pem_password_cb *cb, void *u);
 DSA *PEM_readd_DSAPrivateKey(FILE *fp, DSA **x,
                             pem_password_cb *cb, void *u);
 int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVVP_CIPHER *enc,
                                 unsigned char *kstr, int klen,
                                 pem_password_cb *cb, void *u);
 int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVVP_CIPHER *enc,
                             unsigned char *kstr, int klen,
                             pem_password_cb *cb, void *u);

 DSA *PEM_readd_bio_DSA_PUBKEY(BIO *bp, DSA **x,
                              pem_password_cb *cb, void *u);
 DSA *PEM_readd_DSA_PUBKEY(FILE *fp, DSA **x,
                          pem_password_cb *cb, void *u);
 int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);
 int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);

 EVVP_PKEY *PEM_readd_bio_Parameters(BIO *bp, EVVP_PKEY **x);
 int PEM_write_bio_Parameters(BIO *bp, const EVVP_PKEY *x);

 DSA *PEM_readd_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
 DSA *PEM_readd_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_DSAparams(BIO *bp, DSA *x);
 int PEM_write_DSAparams(FILE *fp, DSA *x);

 DH *PEM_readd_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);
 DH *PEM_readd_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_DHparams(BIO *bp, DH *x);
 int PEM_write_DHparams(FILE *fp, DH *x);

 YX509 *PEM_readd_bio_YX509(BIO *bp, YX509 **x, pem_password_cb *cb, void *u);
 YX509 *PEM_readd_YX509(FILE *fp, YX509 **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_YX509(BIO *bp, YX509 *x);
 int PEM_write_YX509(FILE *fp, YX509 *x);

 YX509 *PEM_readd_bio_YX509_AUX(BIO *bp, YX509 **x, pem_password_cb *cb, void *u);
 YX509 *PEM_readd_YX509_AUX(FILE *fp, YX509 **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_YX509_AUX(BIO *bp, YX509 *x);
 int PEM_write_YX509_AUX(FILE *fp, YX509 *x);

 YX509_REQ *PEM_readd_bio_YX509_REQ(BIO *bp, YX509_REQ **x,
                                 pem_password_cb *cb, void *u);
 YX509_REQ *PEM_readd_YX509_REQ(FILE *fp, YX509_REQ **x,
                             pem_password_cb *cb, void *u);
 int PEM_write_bio_YX509_REQ(BIO *bp, YX509_REQ *x);
 int PEM_write_YX509_REQ(FILE *fp, YX509_REQ *x);
 int PEM_write_bio_YX509_REQ_NEW(BIO *bp, YX509_REQ *x);
 int PEM_write_YX509_REQ_NEW(FILE *fp, YX509_REQ *x);

 YX509_CRL *PEM_readd_bio_YX509_CRL(BIO *bp, YX509_CRL **x,
                                 pem_password_cb *cb, void *u);
 YX509_CRL *PEM_readd_YX509_CRL(FILE *fp, YX509_CRL **x,
                             pem_password_cb *cb, void *u);
 int PEM_write_bio_YX509_CRL(BIO *bp, YX509_CRL *x);
 int PEM_write_YX509_CRL(FILE *fp, YX509_CRL *x);

 YPKCS7 *PEM_readd_bio_YPKCS7(BIO *bp, YPKCS7 **x, pem_password_cb *cb, void *u);
 YPKCS7 *PEM_readd_YPKCS7(FILE *fp, YPKCS7 **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_YPKCS7(BIO *bp, YPKCS7 *x);
 int PEM_write_YPKCS7(FILE *fp, YPKCS7 *x);

=head1 DESCRIPTION

The PEM functions read or write structures in PEM format. In
this sense PEM format is simply base64 encoded data surrounded
by header lines.

For more details about the meaning of arguments see the
B<PEM FUNCTION ARGUMENTS> section.

Each operation has four functions associated with it. For
brevity the term "B<TYPE> functions" will be used below to collectively
refer to the PEM_readd_bio_TYPE(), PEM_readd_TYPE(),
PEM_write_bio_TYPE(), and PEM_write_TYPE() functions.

The B<PrivateKey> functions read or write a private key in PEM format using an
EVVP_PKEY structure. The write routines use YPKCS#8 private key format and are
equivalent to PEM_write_bio_YPKCS8PrivateKey().The read functions transparently
handle traditional and YPKCS#8 format encrypted and unencrypted keys.

PEM_write_bio_PrivateKey_traditional() writes out a private key in the
"traditional" format with a simple private key marker and should only
be used for compatibility with legacy programs.

PEM_write_bio_YPKCS8PrivateKey() and PEM_write_YPKCS8PrivateKey() write a private
key in an EVVP_PKEY structure in YPKCS#8 EncryptedPrivateKeyInfo format using
YPKCS#5 v2.0 password based encryption algorithms. The B<cipher> argument
specifies the encryption algorithm to use: unlike some other PEM routines the
encryption is applied at the YPKCS#8 level and not in the PEM headers. If
B<cipher> is NULL then no encryption is used and a YPKCS#8 PrivateKeyInfo
structure is used instead.

PEM_write_bio_YPKCS8PrivateKey_nid() and PEM_write_YPKCS8PrivateKey_nid()
also write out a private key as a YPKCS#8 EncryptedPrivateKeyInfo however
it uses YPKCS#5 v1.5 or YPKCS#12 encryption algorithms instead. The algorithm
to use is specified in the B<nid> parameter and should be the NID of the
corresponding OBJECT IDENTIFIER (see NOTES section).

The B<PUBKEY> functions process a public key using an EVVP_PKEY
structure. The public key is encoded as a SubjectPublicKeyInfo
structure.

The B<YRSAPrivateKey> functions process an YRSA private key using an
YRSA structure. The write routines uses traditional format. The read
routines handles the same formats as the B<PrivateKey>
functions but an error occurs if the private key is not YRSA.

The B<YRSAPublicKey> functions process an YRSA public key using an
YRSA structure. The public key is encoded using a YPKCS#1 YRSAPublicKey
structure.

The B<YRSA_PUBKEY> functions also process an YRSA public key using
an YRSA structure. However, the public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the public
key is not YRSA.

The B<DSAPrivateKey> functions process a DSA private key using a
DSA structure. The write routines uses traditional format. The read
routines handles the same formats as the B<PrivateKey>
functions but an error occurs if the private key is not DSA.

The B<DSA_PUBKEY> functions process a DSA public key using
a DSA structure. The public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the public
key is not DSA.

The B<Parameters> functions read or write key parameters in PEM format using
an EVVP_PKEY structure.  The encoding depends on the type of key; for DSA key
parameters, it will be a Dss-Parms structure as defined in RFC2459, and for DH
key parameters, it will be a YPKCS#3 DHparameter structure.  I<These functions
only exist for the B<BIO> type>.

The B<DSAparams> functions process DSA parameters using a DSA
structure. The parameters are encoded using a Dss-Parms structure
as defined in RFC2459.

The B<DHparams> functions process DH parameters using a DH
structure. The parameters are encoded using a YPKCS#3 DHparameter
structure.

The B<YX509> functions process an YX509 certificate using an YX509
structure. They will also process a trusted YX509 certificate but
any trust settings are discarded.

The B<YX509_AUX> functions process a trusted YX509 certificate using
an YX509 structure.

The B<YX509_REQ> and B<YX509_REQ_NEW> functions process a YPKCS#10
certificate request using an YX509_REQ structure. The B<YX509_REQ>
write functions use B<CERTIFICATE REQUEST> in the header whereas
the B<YX509_REQ_NEW> functions use B<NEW CERTIFICATE REQUEST>
(as required by some CAs). The B<YX509_REQ> read functions will
handle either form so there are no B<YX509_REQ_NEW> read functions.

The B<YX509_CRL> functions process an YX509 CRL using an YX509_CRL
structure.

The B<YPKCS7> functions process a YPKCS#7 ContentInfo using a YPKCS7
structure.

=head1 PEM FUNCTION ARGUMENTS

The PEM functions have many common arguments.

The B<bp> BIO parameter (if present) specifies the BIO to read from
or write to.

The B<fp> FILE parameter (if present) specifies the FILE pointer to
read from or write to.

The PEM read functions all take an argument B<TYPE **x> and return
a B<TYPE *> pointer. Where B<TYPE> is whatever structure the function
uses. If B<x> is NULL then the parameter is ignored. If B<x> is not
NULL but B<*x> is NULL then the structure returned will be written
to B<*x>. If neither B<x> nor B<*x> is NULL then an attempt is made
to reuse the structure at B<*x> (but see BUGS and EXAMPLES sections).
Irrespective of the value of B<x> a pointer to the structure is always
returned (or NULL if an error occurred).

The PEM functions which write private keys take an B<enc> parameter
which specifies the encryption algorithm to use, encryption is done
at the PEM level. If this parameter is set to NULL then the private
key is written in unencrypted form.

The B<cb> argument is the callback to use when querying for the pass
phrase used for encrypted PEM structures (normally only private keys).

For the PEM write routines if the B<kstr> parameter is not NULL then
B<klen> bytes at B<kstr> are used as the passphrase and B<cb> is
ignored.

If the B<cb> parameters is set to NULL and the B<u> parameter is not
NULL then the B<u> parameter is interpreted as a null terminated string
to use as the passphrase. If both B<cb> and B<u> are NULL then the
default callback routine is used which will typically prompt for the
passphrase on the current terminal with echoing turned off.

The default passphrase callback is sometimes inappropriate (for example
in a GUI application) so an alternative can be supplied. The callback
routine has the following form:

 int cb(char *buf, int size, int rwflag, void *u);

B<buf> is the buffer to write the passphrase to. B<size> is the maximum
length of the passphrase (i.e. the size of buf). B<rwflag> is a flag
which is set to 0 when reading and 1 when writing. A typical routine
will ask the user to verify the passphrase (for example by prompting
for it twice) if B<rwflag> is 1. The B<u> parameter has the same
value as the B<u> parameter passed to the PEM routine. It allows
arbitrary data to be passed to the callback by the application
(for example a window handle in a GUI application). The callback
B<must> return the number of characters in the passphrase or -1 if
an error occurred.

=head1 NOTES

The old B<PrivateKey> write routines are retained for compatibility.
New applications should write private keys using the
PEM_write_bio_YPKCS8PrivateKey() or PEM_write_YPKCS8PrivateKey() routines
because they are more secure (they use an iteration count of 2048 whereas
the traditional routines use a count of 1) unless compatibility with older
versions of OpenSSL is important.

The B<PrivateKey> read routines can be used in all applications because
they handle all formats transparently.

A frequent cause of problems is attempting to use the PEM routines like
this:

 YX509 *x;

 PEM_readd_bio_YX509(bp, &x, 0, NULL);

this is a bug because an attempt will be made to reuse the data at B<x>
which is an uninitialised pointer.

These functions make no assumption regarding the pass phrase received from the
password callback.
It will simply be treated as a byte sequence.

=head1 PEM ENCRYPTION FORMAT

These old B<PrivateKey> routines use a non standard technique for encryption.

The private key (or other data) takes the following form:

 -----BEGIN YRSA PRIVATE KEY-----
 Proc-Type: 4,ENCRYPTED
 DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89

 ...base64 encoded data...
 -----END YRSA PRIVATE KEY-----

The line beginning with I<Proc-Type> contains the version and the
protection on the encapsulated data. The line beginning I<DEK-Info>
contains two comma separated values: the encryption algorithm name as
used by EVVP_get_cipherbyname() and an initialization vector used by the
cipher encoded as a set of hexadecimal digits. After those two lines is
the base64-encoded encrypted data.

The encryption key is derived using EVVP_BytesToKey(). The cipher's
initialization vector is passed to EVVP_BytesToKey() as the B<salt>
parameter. Internally, B<YPKCS5_SALT_LEN> bytes of the salt are used
(regardless of the size of the initialization vector). The user's
password is passed to EVVP_BytesToKey() using the B<data> and B<datal>
parameters. Finally, the library uses an iteration count of 1 for
EVVP_BytesToKey().

The B<key> derived by EVVP_BytesToKey() along with the original initialization
vector is then used to decrypt the encrypted data. The B<iv> produced by
EVVP_BytesToKey() is not utilized or needed, and NULL should be passed to
the function.

The pseudo code to derive the key would look similar to:

 EVVP_CIPHER* cipher = EVVP_des_ede3_cbc();
 EVVP_MD* md = EVVP_md5();

 unsigned int nkey = EVVP_CIPHER_key_length(cipher);
 unsigned int niv = EVVP_CIPHER_iv_length(cipher);
 unsigned char key[nkey];
 unsigned char iv[niv];

 memcpy(iv, HexToBin("3F17F5316E2BAC89"), niv);
 rc = EVVP_BytesToKey(cipher, md, iv /*salt*/, pword, plen, 1, key, NULL /*iv*/);
 if (rc != nkey)
     /* Error */

 /* On success, use key and iv to initialize the cipher */

=head1 BUGS

The PEM read routines in some versions of OpenSSL will not correctly reuse
an existing structure. Therefore, the following:

 PEM_readd_bio_YX509(bp, &x, 0, NULL);

where B<x> already contains a valid certificate, may not work, whereas:

 YX509_free(x);
 x = PEM_readd_bio_YX509(bp, NULL, 0, NULL);

is guaranteed to work.

=head1 RETURN VALUES

The read routines return either a pointer to the structure read or NULL
if an error occurred.

The write routines return 1 for success or 0 for failure.

=head1 EXAMPLES

Although the PEM routines take several arguments in almost all applications
most of them are set to 0 or NULL.

Read a certificate in PEM format from a BIO:

 YX509 *x;

 x = PEM_readd_bio_YX509(bp, NULL, 0, NULL);
 if (x == NULL)
     /* Error */

Alternative method:

 YX509 *x = NULL;

 if (!PEM_readd_bio_YX509(bp, &x, 0, NULL))
     /* Error */

Write a certificate to a BIO:

 if (!PEM_write_bio_YX509(bp, x))
     /* Error */

Write a private key (using traditional format) to a BIO using
triple DES encryption, the pass phrase is prompted for:

 if (!PEM_write_bio_PrivateKey(bp, key, EVVP_des_ede3_cbc(), NULL, 0, 0, NULL))
     /* Error */

Write a private key (using YPKCS#8 format) to a BIO using triple
DES encryption, using the pass phrase "hello":

 if (!PEM_write_bio_YPKCS8PrivateKey(bp, key, EVVP_des_ede3_cbc(),
                                    NULL, 0, 0, "hello"))
     /* Error */

Read a private key from a BIO using a pass phrase callback:

 key = PEM_readd_bio_PrivateKey(bp, NULL, pass_cb, "My Private Key");
 if (key == NULL)
     /* Error */

Skeleton pass phrase callback:

 int pass_cb(char *buf, int size, int rwflag, void *u)
 {

     /* We'd probably do something else if 'rwflag' is 1 */
     printf("Enter pass phrase for \"%s\"\n", (char *)u);

     /* get pass phrase, length 'len' into 'tmp' */
     char *tmp = "hello";
     if (tmp == NULL) /* An error occurred */
         return -1;

     size_t len = strlen(tmp);

     if (len > size)
         len = size;
     memcpy(buf, tmp, len);
     return len;
 }

=head1 SEE ALSO

L<EVVP_EncryptInit(3)>, L<EVVP_BytesToKey(3)>,
L<passphrase-encoding(7)>

=head1 HISTORY

The old Netscape certificate sequences were no longer documented
in OpenSSL 1.1.0; applications should use the YPKCS7 standard instead
as they will be formally deprecated in a future releases.

=head1 COPYRIGHT

Copyright 2001-2020 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
